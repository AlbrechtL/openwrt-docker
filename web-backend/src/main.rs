// Disclaimer: This code is mainly generated by ChatGPT. Quite impressive!
// TODO: I expect that this code needs some refactoring

use std::process::Command;
use tide::{Request, Response, StatusCode, Next};
use serde::Serialize;
use std::str;
use std::future::Future;
use std::pin::Pin;

#[derive(Serialize)]
struct JsonResponse {
    command: String,
    combined_output: String,
}

// Middleware for adding CORS headers
fn cors_middleware<'a>(
    req: Request<()>,
    next: Next<'a, ()>,
) -> Pin<Box<dyn Future<Output = tide::Result> + Send + 'a>> {
    Box::pin(async move {
        let mut res = next.run(req).await;

        res.insert_header("Access-Control-Allow-Origin", "*");
        res.insert_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        res.insert_header("Access-Control-Allow-Headers", "*");

        Ok(res)
    })
}

// Pre-flight handling for OPTIONS method (for browsers)
async fn handle_options(_req: Request<()>) -> tide::Result {
    let mut res = Response::new(StatusCode::Ok);
    res.insert_header("Access-Control-Allow-Origin", "*");
    res.insert_header("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
    res.insert_header("Access-Control-Allow-Headers", "*");
    Ok(res)
}

async fn run_command(command: &str, args: &[&str]) -> JsonResponse {
    let output = Command::new(command)
        .args(args)
        .output()
        .expect("Failed to execute command");

    let stdout = str::from_utf8(&output.stdout).unwrap_or("Invalid UTF-8 in stdout").to_string();
    let stderr = str::from_utf8(&output.stderr).unwrap_or("Invalid UTF-8 in stderr").to_string();

    let combined_output = format!("{}\n{}", stdout, stderr);

    JsonResponse {
        command: format!("{} {:?}", command, args),
        combined_output,
    }
}

async fn endpoint_reboot(_req: Request<()>) -> tide::Result {
    let response_data = run_command("/run/qemu_qmp.sh", &["-R"]).await;
    let mut res = Response::new(StatusCode::Ok);
    res.set_body(serde_json::to_string(&response_data)?);
    res.insert_header("Content-Type", "application/json");
    Ok(res)
}

async fn endpoint_reset(_req: Request<()>) -> tide::Result {
    let response_data = run_command("/run/qemu_qmp.sh", &["-r"]).await;
    let mut res = Response::new(StatusCode::Ok);
    res.set_body(serde_json::to_string(&response_data)?);
    res.insert_header("Content-Type", "application/json");
    Ok(res)
}

async fn endpoint_get_openwrt_info(_req: Request<()>) -> tide::Result {
    let response_data = run_command("/run/qemu_qmp.sh", &["-V"]).await;
    let mut res = Response::new(StatusCode::Ok);
    res.set_body(serde_json::to_string(&response_data)?);
    res.insert_header("Content-Type", "application/json");
    Ok(res)
}

async fn endpoint_get_container_info(_req: Request<()>) -> tide::Result {
    let response_data = run_command("cat", &["/var/www/system_info.txt"]).await;
    let mut res = Response::new(StatusCode::Ok);
    res.set_body(serde_json::to_string(&response_data)?);
    res.insert_header("Content-Type", "application/json");
    Ok(res)
}

async fn endpoint_factory_reset(_req: Request<()>) -> tide::Result {
    let response_data = run_command("/run/factory_reset.sh", &[]).await;
    let mut res = Response::new(StatusCode::Ok);
    res.set_body(serde_json::to_string(&response_data)?);
    res.insert_header("Content-Type", "application/json");
    Ok(res)
}

fn main() -> tide::Result<()> {
    async_std::task::block_on(async {
        println!("*******************************************");
        println!("qemu-openwrt-web-backend proof-of-concept");
        println!("*******************************************");

        let mut app = tide::new();

        // Add CORS middleware
        app.with(cors_middleware);

        // Handle preflight OPTIONS request for CORS
        app.at("/reboot").get(endpoint_reboot).options(handle_options);
        app.at("/reset").get(endpoint_reset).options(handle_options);
        app.at("/get_openwrt_info").get(endpoint_get_openwrt_info).options(handle_options);
        app.at("/get_container_info").get(endpoint_get_container_info).options(handle_options);
        app.at("/factory_reset").get(endpoint_factory_reset).options(handle_options);

        // Start the server at localhost:8080
        app.listen("127.0.0.1:8080").await?;
        Ok(())
    })
}
